# Aether — Reverse Proxy
#
# Single origin: all services behind one domain.
# Dashboard (Next.js) is the default backend.
# /api/* routes go to the orchestrator (except /api/auth/* which is Next.js/better-auth).
#
# Dev:  localhost:3000 (HTTPS, self-signed)
# Prod: {$DOMAIN:localhost} (auto-HTTPS via Let's Encrypt)
#
# Port 3080: plain HTTP for cloudflared tunnel (can't proxy self-signed HTTPS).
# Run: cloudflared tunnel --url http://localhost:3080

# ── Primary HTTPS listener (direct browser access) ──
{$DOMAIN:localhost:3000} {
	handle /webrtc/offer {
		rewrite * /api/webrtc/offer
		reverse_proxy orchestrator:9000
	}
	handle /webrtc/ice {
		rewrite * /api/webrtc/ice
		reverse_proxy orchestrator:9000
	}
	handle /webrtc {
		root * /srv/agent-static
		rewrite * /index.html
		header Cache-Control "no-cache, no-store, must-revalidate"
		file_server
	}
	handle /api/auth/* {
		reverse_proxy dashboard:3000
	}
	handle /api/* {
		reverse_proxy orchestrator:9000
	}
	handle {
		reverse_proxy dashboard:3000
	}
}

# ── HTTP listener for cloudflared tunnel ──
# Cloudflared terminates TLS, so the external URL is https.
# Override X-Forwarded-Proto on the upstream request so the orchestrator
# builds https:// redirect URIs (Caddy's reverse_proxy would otherwise
# set it to "http" since this listener is plain HTTP).
http://:3080 {
	handle /webrtc/offer {
		rewrite * /api/webrtc/offer
		reverse_proxy orchestrator:9000 {
			header_up X-Forwarded-Proto https
		}
	}
	handle /webrtc/ice {
		rewrite * /api/webrtc/ice
		reverse_proxy orchestrator:9000 {
			header_up X-Forwarded-Proto https
		}
	}
	handle /webrtc {
		root * /srv/agent-static
		rewrite * /index.html
		header Cache-Control "no-cache, no-store, must-revalidate"
		file_server
	}
	handle /api/auth/* {
		reverse_proxy dashboard:3000 {
			header_up X-Forwarded-Proto https
		}
	}
	handle /api/* {
		reverse_proxy orchestrator:9000 {
			header_up X-Forwarded-Proto https
		}
	}
	handle {
		reverse_proxy dashboard:3000 {
			header_up X-Forwarded-Proto https
		}
	}
}
