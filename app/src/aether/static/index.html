<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aether Voice</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
            background: #0a0a0a;
            color: #e7e7e7;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .app {
            width: min(820px, 100%);
            border: 1px solid #222;
            border-radius: 14px;
            background: #111;
            padding: 18px;
            display: grid;
            gap: 14px;
        }
        .status {
            font-size: 13px;
            color: #9ca3af;
            min-height: 18px;
        }
        .status.active { color: #4ecdc4; }
        .status.error { color: #ff6b6b; }
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        button {
            background: #1a1a1a;
            color: #d1d5db;
            border: 1px solid #2a2a2a;
            border-radius: 999px;
            padding: 8px 14px;
            cursor: pointer;
        }
        button:hover { border-color: #4ecdc4; color: #4ecdc4; }
        #text {
            width: 100%;
            border-radius: 999px;
            border: 1px solid #2a2a2a;
            background: #0b0b0b;
            color: #e7e7e7;
            padding: 10px 14px;
            outline: none;
        }
        #text:focus { border-color: #4ecdc4; }
        .log {
            border: 1px solid #222;
            border-radius: 10px;
            background: #080808;
            min-height: 320px;
            max-height: 320px;
            overflow: auto;
            padding: 12px;
            display: grid;
            gap: 8px;
        }
        .msg { line-height: 1.4; }
        .msg.user { color: #9ca3af; text-align: right; }
        .msg.assistant { color: #f3f4f6; }
        .hint { color: #6b7280; font-size: 12px; }
    </style>
</head>
<body>
    <div class="app">
        <div id="status" class="status">Tap Connect to start WebRTC</div>
        <div class="controls">
            <button id="connect">Connect</button>
            <button id="start">Start Voice</button>
            <button id="stop">Stop Voice</button>
            <button id="mute">Mute</button>
            <button id="unmute">Unmute</button>
        </div>
        <input id="text" placeholder="Type and press Enter to send text over data channel" />
        <div class="hint">Signaling: <code>/webrtc/offer</code> and <code>/webrtc/ice</code></div>
        <div id="log" class="log"></div>
    </div>

    <script>
    let pc = null;
    let dc = null;
    let localStream = null;
    let remoteAudio = null;
    let pcId = null;
    let partial = null;

    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");

    function setStatus(text, level = "") {
        statusEl.textContent = text;
        statusEl.className = `status ${level}`.trim();
    }

    function addMsg(text, role = "assistant") {
        const div = document.createElement("div");
        div.className = `msg ${role}`;
        div.textContent = text;
        logEl.appendChild(div);
        logEl.scrollTop = logEl.scrollHeight;
        while (logEl.children.length > 60) {
            logEl.removeChild(logEl.firstChild);
        }
    }

    function ensureRemoteAudio() {
        if (!remoteAudio) {
            remoteAudio = document.createElement("audio");
            remoteAudio.autoplay = true;
            document.body.appendChild(remoteAudio);
        }
    }

    async function connect() {
        try {
            setStatus("Requesting microphone...", "active");
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    channelCount: 1,
                    sampleRate: 48000,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                },
            });

            pc = new RTCPeerConnection({
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            });

            localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));

            dc = pc.createDataChannel("aether", { ordered: true });
            dc.onopen = () => setStatus("Connected", "active");
            dc.onmessage = onMessage;

            pc.ontrack = (event) => {
                if (event.track.kind !== "audio") return;
                ensureRemoteAudio();
                remoteAudio.srcObject = event.streams[0] || new MediaStream([event.track]);
            };

            const gathered = [];
            pc.onicecandidate = (event) => {
                if (!event.candidate) return;
                gathered.push({
                    candidate: event.candidate.candidate,
                    sdpMid: event.candidate.sdpMid,
                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                });
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            await new Promise((resolve) => {
                if (pc.iceGatheringState === "complete") {
                    resolve();
                    return;
                }
                const timer = setTimeout(resolve, 3000);
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === "complete") {
                        clearTimeout(timer);
                        resolve();
                    }
                };
            });

            const offerResp = await fetch("/webrtc/offer", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    sdp: pc.localDescription.sdp,
                    type: pc.localDescription.type,
                    user_id: "web-rtc-test",
                }),
            });
            if (!offerResp.ok) throw new Error(`Offer failed (${offerResp.status})`);

            const answer = await offerResp.json();
            pcId = answer.pc_id;
            await pc.setRemoteDescription(new RTCSessionDescription(answer));

            if (gathered.length > 0) {
                await fetch("/webrtc/ice", {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ pc_id: pcId, candidates: gathered }),
                });
            }

            setStatus("Connected. Press Start Voice.", "active");
        } catch (err) {
            setStatus(`Connection error: ${err.message}`, "error");
        }
    }

    function onMessage(event) {
        let msg;
        try {
            msg = JSON.parse(event.data);
        } catch {
            return;
        }

        if (msg.type === "transcript") {
            if (msg.role === "assistant") {
                addMsg(msg.data, "assistant");
            } else if (!msg.interim && msg.data) {
                addMsg(msg.data, "user");
            }
            return;
        }

        if (msg.type === "text_chunk") {
            if (!partial) {
                partial = document.createElement("div");
                partial.className = "msg assistant";
                partial.textContent = msg.data;
                logEl.appendChild(partial);
            } else {
                partial.textContent += msg.data;
            }
            logEl.scrollTop = logEl.scrollHeight;
            return;
        }

        if (msg.type === "stream_end") {
            partial = null;
            return;
        }

        if (msg.type === "error" && msg.data) {
            setStatus(`Error: ${msg.data}`, "error");
            addMsg(`Error: ${msg.data}`, "assistant");
            partial = null;
            return;
        }

        if (msg.type === "status" && msg.data) {
            setStatus(msg.data, "active");
        }
    }

    function send(type, data = undefined) {
        if (!dc || dc.readyState !== "open") {
            setStatus("Data channel is not ready (state=" + (dc ? dc.readyState : "null") + ")", "error");
            return;
        }
        const payload = data === undefined ? { type } : { type, data };
        const msg = JSON.stringify(payload);
        console.log("DC send:", msg, "buffered:", dc.bufferedAmount);
        dc.send(msg);
        setStatus("Sent: " + type, "active");
    }

    document.getElementById("connect").addEventListener("click", connect);
    document.getElementById("start").addEventListener("click", () => send("stream_start"));
    document.getElementById("stop").addEventListener("click", () => send("stream_stop"));
    document.getElementById("mute").addEventListener("click", () => {
        send("mute");
        if (localStream) localStream.getAudioTracks().forEach((t) => { t.enabled = false; });
    });
    document.getElementById("unmute").addEventListener("click", () => {
        send("unmute");
        if (localStream) localStream.getAudioTracks().forEach((t) => { t.enabled = true; });
    });

    document.getElementById("text").addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        const value = e.target.value.trim();
        if (!value) return;
        send("text", value);
        e.target.value = "";
    });
    </script>
</body>
</html>
