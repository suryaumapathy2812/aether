<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aether Voice</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
            background: #0a0a0a;
            color: #e7e7e7;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .app {
            width: min(820px, 100%);
            border: 1px solid #222;
            border-radius: 14px;
            background: #111;
            padding: 18px;
            display: grid;
            gap: 14px;
        }
        .status {
            font-size: 13px;
            color: #9ca3af;
            min-height: 18px;
        }
        .status.active { color: #4ecdc4; }
        .status.error  { color: #ff6b6b; }
        .status.warn   { color: #f59e0b; }
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        button {
            background: #1a1a1a;
            color: #d1d5db;
            border: 1px solid #2a2a2a;
            border-radius: 999px;
            padding: 8px 14px;
            cursor: pointer;
        }
        button:hover { border-color: #4ecdc4; color: #4ecdc4; }
        button:disabled { opacity: 0.4; cursor: default; }
        #text {
            width: 100%;
            border-radius: 999px;
            border: 1px solid #2a2a2a;
            background: #0b0b0b;
            color: #e7e7e7;
            padding: 10px 14px;
            outline: none;
        }
        #text:focus { border-color: #4ecdc4; }
        /* Live interim transcript bar */
        #interim-bar {
            min-height: 20px;
            font-size: 13px;
            color: #6b7280;
            font-style: italic;
            padding: 0 4px;
            transition: opacity 0.2s;
        }
        #interim-bar:empty { opacity: 0; }
        .log {
            border: 1px solid #222;
            border-radius: 10px;
            background: #080808;
            min-height: 320px;
            max-height: 320px;
            overflow: auto;
            padding: 12px;
            display: grid;
            gap: 8px;
            align-content: start;
        }
        .msg { line-height: 1.4; }
        .msg.user      { color: #9ca3af; text-align: right; }
        .msg.assistant { color: #f3f4f6; }
        .hint { color: #6b7280; font-size: 12px; }
    </style>
</head>
<body>
    <div class="app">
        <div id="status" class="status">Connecting…</div>
        <div class="controls">
            <button id="start">Start Voice</button>
            <button id="stop">Stop Voice</button>
            <button id="mute">Mute</button>
            <button id="unmute">Unmute</button>
            <button id="disconnect">Disconnect</button>
        </div>
        <div id="interim-bar"></div>
        <input id="text" placeholder="Type and press Enter to send text over data channel" />
        <div class="hint">Auto-connects on load · Auto-reconnects on drop</div>
        <div id="log" class="log"></div>
    </div>

    <script>
    // ── State ──────────────────────────────────────────────────────
    let pc = null;
    let dc = null;
    let localStream = null;
    let remoteAudio = null;
    let pcId = null;
    let partial = null;          // streaming assistant text_chunk bubble
    let reconnectTimer = null;
    let reconnectDelay = 1000;   // ms, doubles on each failure (max 30s)
    let intentionalDisconnect = false;
    let streaming = false;       // true after stream_start sent

    const MAX_RECONNECT_DELAY = 30000;

    const statusEl   = document.getElementById("status");
    const logEl      = document.getElementById("log");
    const interimEl  = document.getElementById("interim-bar");

    // ── UI helpers ─────────────────────────────────────────────────

    function setStatus(text, level = "") {
        statusEl.textContent = text;
        statusEl.className = `status ${level}`.trim();
    }

    function addMsg(text, role = "assistant") {
        const div = document.createElement("div");
        div.className = `msg ${role}`;
        div.textContent = text;
        logEl.appendChild(div);
        logEl.scrollTop = logEl.scrollHeight;
        while (logEl.children.length > 80) logEl.removeChild(logEl.firstChild);
    }

    function ensureRemoteAudio() {
        if (!remoteAudio) {
            remoteAudio = document.createElement("audio");
            remoteAudio.autoplay = true;
            document.body.appendChild(remoteAudio);
        }
    }

    // ── Reconnect logic ────────────────────────────────────────────

    function scheduleReconnect() {
        if (intentionalDisconnect) return;
        clearTimeout(reconnectTimer);
        setStatus(`Reconnecting in ${(reconnectDelay / 1000).toFixed(1)}s…`, "warn");
        reconnectTimer = setTimeout(() => {
            connect(/* isReconnect= */ true);
        }, reconnectDelay);
        reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
    }

    function resetReconnectDelay() {
        reconnectDelay = 1000;
    }

    function markDataChannelReady() {
        if (!dc || dc.readyState !== "open") return false;
        resetReconnectDelay();
        if (!streaming) {
            send("stream_start");
            streaming = true;
        }
        setStatus("Listening…", "active");
        return true;
    }

    // ── Core connect ───────────────────────────────────────────────

    async function connect(isReconnect = false) {
        // Tear down any existing peer connection first
        if (pc) {
            try { pc.close(); } catch (_) {}
            pc = null; dc = null;
        }

        try {
            setStatus("Requesting microphone…", "active");

            if (!localStream) {
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 48000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                    },
                });
            }

            pc = new RTCPeerConnection({
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            });

            localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));

            dc = pc.createDataChannel("aether", { ordered: true });

            dc.onopen = () => {
                markDataChannelReady();
            };

            dc.onclose = () => {
                streaming = false;
                if (!intentionalDisconnect) scheduleReconnect();
            };

            dc.onerror = () => {
                streaming = false;
                if (!intentionalDisconnect) scheduleReconnect();
            };

            dc.onmessage = onMessage;

            pc.ontrack = (event) => {
                if (event.track.kind !== "audio") return;
                ensureRemoteAudio();
                remoteAudio.srcObject = event.streams[0] || new MediaStream([event.track]);
            };

            pc.onconnectionstatechange = () => {
                const s = pc.connectionState;
                if (s === "connected") {
                    markDataChannelReady();
                }
                if (s === "disconnected" || s === "failed" || s === "closed") {
                    streaming = false;
                    if (!intentionalDisconnect) scheduleReconnect();
                }
            };

            // Gather ICE candidates
            const gathered = [];
            pc.onicecandidate = (event) => {
                if (!event.candidate) return;
                gathered.push({
                    candidate: event.candidate.candidate,
                    sdpMid: event.candidate.sdpMid,
                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                });
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // Wait for ICE gathering (max 3s)
            await new Promise((resolve) => {
                if (pc.iceGatheringState === "complete") { resolve(); return; }
                const timer = setTimeout(resolve, 3000);
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === "complete") {
                        clearTimeout(timer);
                        resolve();
                    }
                };
            });

            setStatus("Sending offer…", "active");

            const offerResp = await fetch("/webrtc/offer", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    sdp: pc.localDescription.sdp,
                    type: pc.localDescription.type,
                    user_id: "web-rtc-test",
                }),
            });
            if (!offerResp.ok) throw new Error(`Offer failed (${offerResp.status})`);

            const answer = await offerResp.json();
            pcId = answer.pc_id;
            await pc.setRemoteDescription(new RTCSessionDescription(answer));

            if (gathered.length > 0) {
                await fetch("/webrtc/ice", {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ pc_id: pcId, candidates: gathered }),
                });
            }

            setStatus("Waiting for data channel…", "active");
            setTimeout(() => {
                if (pc && pc.connectionState === "connected") {
                    markDataChannelReady();
                }
            }, 1200);

        } catch (err) {
            setStatus(`Connection error: ${err.message}`, "error");
            if (!intentionalDisconnect) scheduleReconnect();
        }
    }

    // ── Message handler ────────────────────────────────────────────

    function onMessage(event) {
        let msg;
        try { msg = JSON.parse(event.data); } catch { return; }

        // Live interim transcript — show in the interim bar (ghost text)
        if (msg.type === "transcript" && msg.interim) {
            interimEl.textContent = msg.data || "";
            return;
        }

        // Committed user transcript — move from interim bar to log
        if (msg.type === "transcript" && msg.role !== "assistant") {
            interimEl.textContent = "";
            if (msg.data) addMsg(msg.data, "user");
            return;
        }

        // Final assistant transcript (non-streaming path)
        if (msg.type === "transcript" && msg.role === "assistant") {
            addMsg(msg.data, "assistant");
            return;
        }

        // Streaming assistant text chunks
        if (msg.type === "text_chunk") {
            if (!partial) {
                partial = document.createElement("div");
                partial.className = "msg assistant";
                partial.textContent = msg.data;
                logEl.appendChild(partial);
            } else {
                partial.textContent += msg.data;
            }
            logEl.scrollTop = logEl.scrollHeight;
            return;
        }

        if (msg.type === "stream_end") {
            partial = null;
            interimEl.textContent = "";
            return;
        }

        if (msg.type === "error" && msg.data) {
            setStatus(`Error: ${msg.data}`, "error");
            addMsg(`Error: ${msg.data}`, "assistant");
            partial = null;
            return;
        }

        if (msg.type === "status" && msg.data) {
            setStatus(msg.data, "active");
        }
    }

    // ── Send helper ────────────────────────────────────────────────

    function send(type, data = undefined) {
        if (!dc || dc.readyState !== "open") return;
        const payload = data === undefined ? { type } : { type, data };
        dc.send(JSON.stringify(payload));
    }

    // ── Button handlers ────────────────────────────────────────────

    document.getElementById("start").addEventListener("click", () => {
        send("stream_start");
        streaming = true;
    });

    document.getElementById("stop").addEventListener("click", () => {
        send("stream_stop");
        streaming = false;
    });

    document.getElementById("mute").addEventListener("click", () => {
        send("mute");
        if (localStream) localStream.getAudioTracks().forEach((t) => { t.enabled = false; });
    });

    document.getElementById("unmute").addEventListener("click", () => {
        send("unmute");
        if (localStream) localStream.getAudioTracks().forEach((t) => { t.enabled = true; });
    });

    document.getElementById("disconnect").addEventListener("click", () => {
        intentionalDisconnect = true;
        clearTimeout(reconnectTimer);
        send("stream_stop");
        if (pc) { try { pc.close(); } catch (_) {} pc = null; dc = null; }
        streaming = false;
        setStatus("Disconnected", "");
    });

    document.getElementById("text").addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        const value = e.target.value.trim();
        if (!value) return;
        send("text", value);
        addMsg(value, "user");
        e.target.value = "";
    });

    // ── Auto-connect on page load ──────────────────────────────────
    connect();
    </script>
</body>
</html>
